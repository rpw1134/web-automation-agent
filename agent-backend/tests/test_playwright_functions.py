"""
AI-GENERATED TEST FILE FOR LEARNING PURPOSES

This test file was generated by AI to demonstrate testing patterns for
Playwright-based web automation functions. It uses pytest and mocking
to test browser automation functions without requiring a real browser.

Key Testing Patterns Demonstrated:
- Async function testing with pytest-asyncio
- Mocking external dependencies (Playwright, BrowserManager)
- Testing success and failure scenarios
- Testing timeout handling
- Testing error message formatting
"""

import pytest
from uuid import uuid4, UUID
from unittest.mock import AsyncMock, patch
from playwright.async_api import Page, BrowserContext

# Import the functions to test
from agent_backend.tools.playwright_functions import (
    go_to_url,
    click,
    type_text,
    extract_text,
    wait_for_selector,
    evaluate_script,
    scroll,
    set_viewport_size,
    reload_page,
    screenshot_page,
    get_open_pages
)
from agent_backend.types.tool import ToolResponse


@pytest.fixture
def context_id() -> UUID:
    """
    Fixture providing a mock context ID.

    Returns a UUID that can be used throughout tests to simulate
    a browser context identifier.
    """
    return uuid4()


@pytest.fixture
def page_id() -> UUID:
    """
    Fixture providing a mock page ID.

    Returns a UUID that can be used throughout tests to simulate
    a page identifier.
    """
    return uuid4()


@pytest.fixture
def mock_page():
    """
    Fixture providing a mocked Playwright Page object.

    This mock includes commonly used page methods like goto, click,
    fill, etc. All methods are AsyncMock to support async/await.
    """
    page = AsyncMock(spec=Page)
    page.goto = AsyncMock()
    page.click = AsyncMock()
    page.fill = AsyncMock()
    page.text_content = AsyncMock()
    page.wait_for_selector = AsyncMock()
    page.evaluate = AsyncMock()
    page.set_viewport_size = AsyncMock()
    page.reload = AsyncMock()
    page.screenshot = AsyncMock()
    return page


@pytest.fixture
def mock_browser_context():
    """
    Fixture providing a mocked Playwright BrowserContext object.

    Includes the pages property that returns a list of pages.
    """
    context = AsyncMock(spec=BrowserContext)
    context.pages = []
    return context


class TestGoToUrl:
    """
    Tests for the go_to_url function.

    This function navigates to a specified URL and returns the page ID and Page object.
    Tests verify that:
    - Pages are created correctly
    - Navigation to URLs works
    - The function returns the correct tuple format
    """

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.create_page')
    async def test_go_to_url_success(self, mock_create_page, context_id, page_id, mock_page):
        """
        Test successful navigation to a URL.

        Verifies that go_to_url creates a page and navigates to the specified URL.
        """
        # Arrange: Set up mock to return page_id and mock_page
        mock_create_page.return_value = (page_id, mock_page)
        url = "https://example.com"

        # Act: Call the function
        result = await go_to_url(context_id, url)

        # Assert: Verify the function behaved correctly
        assert isinstance(result, ToolResponse)
        assert result.success is True
        assert url in result.content
        assert str(page_id) in result.content
        mock_create_page.assert_called_once_with(context_id)
        mock_page.goto.assert_called_once_with(url, timeout=30000)


class TestClick:
    """
    Tests for the click function.

    This function clicks an element on a page using a CSS selector.
    Tests cover success cases, timeout errors, and unexpected errors.
    """

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_click_success(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test successful element click.

        Verifies that clicking an element works when the selector is found.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        selector = "#submit-button"

        # Act
        result = await click(context_id, page_id, selector)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is True
        mock_get_page.assert_called_once_with(context_id, page_id)
        mock_page.click.assert_called_once_with(selector=selector, timeout=5000)
        assert "Successfully clicked element" in result.content
        assert selector in result.content

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_click_timeout(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test click timeout handling.

        Verifies that a timeout error is properly caught and an appropriate
        error message is returned.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        mock_page.click.side_effect = TimeoutError()
        selector = "#missing-button"

        # Act
        result = await click(context_id, page_id, selector)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is False
        assert "ERROR" in result.content
        assert "timed out" in result.content.lower()
        assert selector in result.content

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_click_unexpected_error(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test handling of unexpected errors during click.

        Verifies that unexpected exceptions are caught and reported.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        mock_page.click.side_effect = Exception("Network error")
        selector = "#error-button"

        # Act
        result = await click(context_id, page_id, selector)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is False
        assert "ERROR" in result.content
        assert "Unexpected error" in result.content
        assert "Network error" in result.content


class TestTypeText:
    """
    Tests for the type_text function.

    This function types text into an input field identified by a selector.
    Tests verify success, timeout, and error scenarios.
    """

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_type_text_success(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test successful text input.

        Verifies that text is correctly filled into an input field.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        selector = "#username"
        text = "test_user"

        # Act
        result = await type_text(context_id, page_id, selector, text)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is True
        mock_page.fill.assert_called_once_with(selector=selector, value=text, timeout=5000)
        assert "Successfully typed text" in result.content
        assert text in result.content

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_type_text_timeout(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test type_text timeout handling.

        Verifies proper error message when the input field is not found.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        mock_page.fill.side_effect = TimeoutError()
        selector = "#missing-input"

        # Act
        result = await type_text(context_id, page_id, selector, "test")

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is False
        assert "ERROR" in result.content
        assert "timed out" in result.content.lower()
        assert selector in result.content


class TestExtractText:
    """
    Tests for the extract_text function.

    This function extracts text content from an element on the page.
    Tests cover successful extraction, empty content, timeouts, and errors.
    """

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_extract_text_success(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test successful text extraction.

        Verifies that text content is extracted and whitespace is stripped.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        mock_page.text_content.return_value = "  Hello World  "
        selector = "#heading"

        # Act
        result = await extract_text(context_id, page_id, selector)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is True
        mock_page.text_content.assert_called_once_with(selector=selector, timeout=5000)
        assert result.content == "Hello World"

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_extract_text_no_content(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test extraction when element has no text content.

        Verifies proper handling when text_content returns None.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        mock_page.text_content.return_value = None
        selector = "#empty"

        # Act
        result = await extract_text(context_id, page_id, selector)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is False
        assert "ERROR" in result.content
        assert "No text content found" in result.content
        assert selector in result.content

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_extract_text_timeout(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test extract_text timeout handling.

        Verifies proper error message when element is not found.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        mock_page.text_content.side_effect = TimeoutError()
        selector = "#missing"

        # Act
        result = await extract_text(context_id, page_id, selector)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is False
        assert "ERROR" in result.content
        assert "timed out" in result.content.lower()


class TestWaitForSelector:
    """
    Tests for the wait_for_selector function.

    This function waits for an element to appear on the page.
    Tests verify default timeout, custom timeout, and timeout errors.
    """

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_wait_for_selector_success(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test successful wait for element.

        Verifies that the function waits with default timeout.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        selector = "#loading-indicator"

        # Act
        result = await wait_for_selector(context_id, page_id, selector)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is True
        mock_page.wait_for_selector.assert_called_once_with(selector=selector, timeout=5000)
        assert "is now present" in result.content

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_wait_for_selector_custom_timeout(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test wait_for_selector with custom timeout.

        Verifies that custom timeout values are passed correctly.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        selector = "#slow-element"
        custom_timeout = 10000

        # Act
        result = await wait_for_selector(context_id, page_id, selector, timeout=custom_timeout)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is True
        mock_page.wait_for_selector.assert_called_once_with(selector=selector, timeout=custom_timeout)

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_wait_for_selector_timeout(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test wait_for_selector timeout error.

        Verifies proper error message when element never appears.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        mock_page.wait_for_selector.side_effect = TimeoutError()
        selector = "#never-appears"

        # Act
        result = await wait_for_selector(context_id, page_id, selector)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is False
        assert "ERROR" in result.content
        assert "timed out" in result.content.lower()
        assert "5000ms" in result.content


class TestEvaluateScript:
    """
    Tests for the evaluate_script function.

    This function executes JavaScript code in the browser context.
    Tests verify successful script execution and error handling.
    """

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_evaluate_script_success(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test successful script evaluation.

        Verifies that JavaScript code is executed and results are returned.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        mock_page.evaluate.return_value = {"title": "Example Page"}
        script = "document.title"

        # Act
        result = await evaluate_script(context_id, page_id, script)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is True
        mock_page.evaluate.assert_called_once_with(expression=script, arg=None)
        assert "{'title': 'Example Page'}" in result.content

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_evaluate_script_with_arg(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test script evaluation with argument.

        Verifies that arguments are passed to the evaluated script.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        mock_page.evaluate.return_value = "result"
        script = "arg => arg.toUpperCase()"
        arg = "hello"

        # Act
        result = await evaluate_script(context_id, page_id, script, arg)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is True
        mock_page.evaluate.assert_called_once_with(expression=script, arg=arg)
        assert "result" in result.content

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_evaluate_script_error(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test script evaluation error handling.

        Verifies that JavaScript errors are caught and reported.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        mock_page.evaluate.side_effect = Exception("ReferenceError: x is not defined")

        # Act
        result = await evaluate_script(context_id, page_id, "return x;")

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is False
        assert "ERROR" in result.content
        assert "Unexpected error" in result.content
        assert "ReferenceError" in result.content


class TestScroll:
    """
    Tests for the scroll function.

    This function scrolls the page to a specific x, y coordinate.
    Tests verify successful scrolling and error handling.
    """

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_scroll_success(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test successful page scrolling.

        Verifies that the page scrolls to the specified coordinates.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        x, y = 0, 500

        # Act
        result = await scroll(context_id, page_id, x, y)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is True
        mock_page.evaluate.assert_called_once_with(f"window.scrollTo({x}, {y});")
        assert "Successfully scrolled" in result.content
        assert f"({x}, {y})" in result.content

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_scroll_error(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test scroll error handling.

        Verifies that scroll errors are caught and reported.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        mock_page.evaluate.side_effect = Exception("Scroll failed")

        # Act
        result = await scroll(context_id, page_id, 0, 100)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is False
        assert "ERROR" in result.content
        assert "Unexpected error scrolling" in result.content


class TestSetViewportSize:
    """
    Tests for the set_viewport_size function.

    This function sets the viewport dimensions of the page.
    Tests verify successful viewport changes and error handling.
    """

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_set_viewport_size_success(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test successful viewport size change.

        Verifies that viewport dimensions are set correctly.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        width, height = 1920, 1080

        # Act
        result = await set_viewport_size(context_id, page_id, width, height)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is True
        mock_page.set_viewport_size.assert_called_once_with({"width": width, "height": height})
        assert "Successfully set viewport" in result.content
        assert f"({width}, {height})" in result.content

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_set_viewport_size_error(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test set_viewport_size error handling.

        Verifies that errors during viewport changes are caught.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        mock_page.set_viewport_size.side_effect = Exception("Invalid dimensions")

        # Act
        result = await set_viewport_size(context_id, page_id, -1, -1)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is False
        assert "ERROR" in result.content
        assert "Unexpected error" in result.content


class TestReloadPage:
    """
    Tests for the reload_page function.

    This function reloads the current page.
    Tests verify successful reload and error handling.
    """

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_reload_page_success(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test successful page reload.

        Verifies that the page reload method is called.
        """
        # Arrange
        mock_get_page.return_value = mock_page

        # Act
        result = await reload_page(context_id, page_id)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is True
        mock_page.reload.assert_called_once()
        assert "Successfully reloaded" in result.content

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_reload_page_error(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test reload_page error handling.

        Verifies that errors during reload are caught and reported.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        mock_page.reload.side_effect = Exception("Network error")

        # Act
        result = await reload_page(context_id, page_id)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is False
        assert "ERROR" in result.content
        assert "Unexpected error" in result.content


class TestScreenshotPage:
    """
    Tests for the screenshot_page function.

    This function takes a screenshot of the page and saves it to a file.
    Tests verify successful screenshot capture and error handling.
    """

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_screenshot_page_success(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test successful screenshot capture.

        Verifies that a screenshot is saved to the specified path.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        path = "/tmp/screenshot.png"

        # Act
        result = await screenshot_page(context_id, page_id, path)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is True
        mock_page.screenshot.assert_called_once_with(path=path)
        assert "Successfully took screenshot" in result.content
        assert path in result.content

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_page_by_id')
    async def test_screenshot_page_error(self, mock_get_page, context_id, page_id, mock_page):
        """
        Test screenshot_page error handling.

        Verifies that errors during screenshot capture are caught.
        """
        # Arrange
        mock_get_page.return_value = mock_page
        mock_page.screenshot.side_effect = Exception("Permission denied")

        # Act
        result = await screenshot_page(context_id, page_id, "/invalid/path.png")

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is False
        assert "ERROR" in result.content
        assert "Unexpected error" in result.content


class TestGetOpenPages:
    """
    Tests for the get_open_pages function.

    This function retrieves all open pages in a browser context.
    Tests verify that the context's pages are returned correctly.
    """

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_browser_context_by_id')
    async def test_get_open_pages_success(self, mock_get_context, context_id, mock_browser_context):
        """
        Test successful retrieval of open pages.

        Verifies that all pages in the context are returned.
        """
        # Arrange
        mock_get_context.return_value = mock_browser_context
        mock_page1 = AsyncMock(spec=Page)
        mock_page1.url = "https://example.com/page1"
        mock_page2 = AsyncMock(spec=Page)
        mock_page2.url = "https://example.com/page2"
        mock_browser_context.pages = [mock_page1, mock_page2]

        # Act
        result = await get_open_pages(context_id)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is True
        mock_get_context.assert_called_once_with(context_id)
        assert "Page 0:" in result.content
        assert "Page 1:" in result.content
        assert "example.com/page1" in result.content
        assert "example.com/page2" in result.content

    @pytest.mark.asyncio
    @patch('agent_backend.tools.playwright_functions.get_browser_context_by_id')
    async def test_get_open_pages_empty(self, mock_get_context, context_id, mock_browser_context):
        """
        Test get_open_pages with no open pages.

        Verifies that an appropriate message is returned when no pages are open.
        """
        # Arrange
        mock_get_context.return_value = mock_browser_context
        mock_browser_context.pages = []

        # Act
        result = await get_open_pages(context_id)

        # Assert
        assert isinstance(result, ToolResponse)
        assert result.success is True
        assert "No open pages" in result.content
